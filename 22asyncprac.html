<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <button id = "button">버튼</button>

    <script>


        async function 프로미스요() {
            let pr = new Promise(function(resolve, reject) {
                document.getElementById('button').addEventListener('click', function() {
                    resolve('성공');
                })
            });

            let result1 = await pr;
            alert(result1);
        }

        프로미스요();

        /////////////////////////////////////////////////////////////////////////////////////////////


        // async function 프로미스() {
        //     document.getElementById('button').addEventListener('click', function(){
        //         return '성공'
        //     });
        // }

        // async function 버튼눌러() {
        //     let result = await 프로미스();
        //     console.log(result);
        // }

        // 버튼눌러();

        // 문제점
        // async가 Promise를 뱉는다해서 async function 프로미스()를 쓰고 이벤트리스너를 안에 담기는 했는데
        // 버튼 누르면 return 어쩌구 때문에 성공판정이 될거라 기대 했지만 안된다.

        // return '성공' 이게 async function의 return이 아니고 이벤트리스너 안의 함수의 return 문이라 문제되는것도 있지만
        // 더 중요한 문제는 아래와 같다.

        // 이벤트 리스너 안의 코드는 바로 실행되지 않는다. 버튼 누를때 실행
        // 컴퓨터가 코드를 쭉 읽을 때 async function 프로미스() 함수 내부는 빈칸과 동일하다.
        // 자바스크립트는 function 안이 빈칸이면 그냥 자동으로 return undefined를 채워 실행한다.

        // 그럼 3번에 의해서 asyunc function 프로미스()는 0 초만에 자동으로 성공() 판정이 된다.

        // 그래서 하단의 
        // let result = await 프로미스();
        // 이코드는 프로미스()가 0초만에 성공판정이 내려진 상태로 실행되며 (undefined가 자동으로 채워지니까)
        // let result = undefined와 동일한 뜻이다.
        // 그래서 코드가 이상.
        // 하지만 Promise로 만들어서 직접 resolve(), reject() 경우를 지정해주면 await이 잘 기다린다.

    </script>
    
</body>
</html>